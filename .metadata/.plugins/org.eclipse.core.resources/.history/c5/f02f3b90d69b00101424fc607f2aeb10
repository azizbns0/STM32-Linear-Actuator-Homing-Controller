/*
 * homing.c - FIXED VERSION
 */

#include "homing.h"
#include "homing_hal.h"
#include <math.h>

// Switch debouncer structure
typedef struct {
    bool current_state;
    bool last_raw_state;
    uint32_t last_change_time;
} switch_debouncer_t;

// Static variables
static switch_debouncer_t left_switch_db;
static switch_debouncer_t right_switch_db;

// Private function declarations
static bool debounce_switch(switch_debouncer_t *db, bool raw_state, uint32_t now, uint32_t debounce_time);
static uint32_t calculate_center_time(const homing_context_t *ctx);
static void enter_error_state(homing_context_t *ctx, homing_error_t error);
static void change_state(homing_context_t *ctx, homing_state_t new_state);
static bool check_timeout(const homing_context_t *ctx, uint32_t now);

// Public API Implementation

void homing_init(homing_context_t *ctx) {
    // Initialize context
    ctx->state = HOMING_STATE_IDLE;
    ctx->error_code = HOMING_ERROR_NONE;
    ctx->state_start_time = 0;
    ctx->measurement_start_time = 0;
    ctx->timeout_ms = HOMING_DEFAULT_TIMEOUT_MS;
    ctx->debounce_ms = HOMING_DEFAULT_DEBOUNCE_MS;

    // Clear measurements
    ctx->time_left_to_right_ms = 0;
    ctx->time_right_to_left_ms = 0;
    ctx->center_time_ms = 0;

    // Clear flags
    ctx->measurement_active = false;
    ctx->center_move_started = false;
    ctx->enable_asymmetric_calculation = false;

    // Initialize debouncers
    left_switch_db.current_state = false;
    left_switch_db.last_raw_state = false;
    left_switch_db.last_change_time = 0;

    right_switch_db.current_state = false;
    right_switch_db.last_raw_state = false;
    right_switch_db.last_change_time = 0;

    // Initialize hardware
    hal_actuator_stop();
    hal_clear_switches();
}

void homing_start(homing_context_t *ctx) {
    if (ctx->state == HOMING_STATE_IDLE ||
        ctx->state == HOMING_STATE_COMPLETE ||
        ctx->state == HOMING_STATE_ERROR) {

        // Reset all measurements and flags
        ctx->time_left_to_right_ms = 0;
        ctx->time_right_to_left_ms = 0;
        ctx->center_time_ms = 0;
        ctx->measurement_active = false;
        ctx->center_move_started = false;
        ctx->error_code = HOMING_ERROR_NONE;

        // Start homing sequence
        change_state(ctx, HOMING_STATE_MOVE_TO_LEFT);
        hal_actuator_move_left();
    }
}

void homing_update(homing_context_t *ctx) {
    uint32_t now = hal_get_tick_ms();

    // Update switch states with debouncing
    bool left_switch = debounce_switch(&left_switch_db, hal_get_left_switch_raw(), now, ctx->debounce_ms);
    bool right_switch = debounce_switch(&right_switch_db, hal_get_right_switch_raw(), now, ctx->debounce_ms);

    switch (ctx->state) {
        case HOMING_STATE_IDLE:
        case HOMING_STATE_COMPLETE:
        case HOMING_STATE_ERROR:
            // Nothing to do in these states
            break;

        case HOMING_STATE_MOVE_TO_LEFT:
            if (left_switch) {
                // Reached left switch, prepare for measurement
                hal_actuator_stop();
                change_state(ctx, HOMING_STATE_MEASURE_LEFT_TO_RIGHT);
                // Small delay to ensure actuator has stopped
            } else if (check_timeout(ctx, now)) {
                enter_error_state(ctx, HOMING_ERROR_TIMEOUT_MOVE_LEFT);
            }
            break;

        case HOMING_STATE_MEASURE_LEFT_TO_RIGHT:
            if (left_switch && !ctx->measurement_active) {
                // Still on left switch, move right but don't start measuring yet
                hal_actuator_move_right();
            } else if (!left_switch && !ctx->measurement_active) {
                // Just left the switch, start measurement
                ctx->measurement_start_time = now;
                ctx->measurement_active = true;
                hal_actuator_move_right();
            } else if (ctx->measurement_active && right_switch) {
                // Reached right switch, measurement complete
                ctx->time_left_to_right_ms = now - ctx->measurement_start_time;
                ctx->measurement_active = false;
                hal_actuator_stop();
                change_state(ctx, HOMING_STATE_MEASURE_RIGHT_TO_LEFT);
            } else if (check_timeout(ctx, now)) {
                enter_error_state(ctx, HOMING_ERROR_TIMEOUT_MEASURE_LR);
            }
            break;

        case HOMING_STATE_MEASURE_RIGHT_TO_LEFT:
            if (right_switch && !ctx->measurement_active) {
                // Still on right switch, move left but don't start measuring yet
                hal_actuator_move_left();
            } else if (!right_switch && !ctx->measurement_active) {
                // Just left the switch, start measurement
                ctx->measurement_start_time = now;
                ctx->measurement_active = true;
                hal_actuator_move_left();
            } else if (ctx->measurement_active && left_switch) {
                // Reached left switch, measurement complete
                ctx->time_right_to_left_ms = now - ctx->measurement_start_time;
                ctx->measurement_active = false;

                // Calculate center position
                ctx->center_time_ms = calculate_center_time(ctx);

                if (ctx->center_time_ms == 0) {
                    enter_error_state(ctx, HOMING_ERROR_INVALID_MEASUREMENT);
                } else {
                    hal_actuator_stop();
                    change_state(ctx, HOMING_STATE_MOVE_TO_CENTER);
                }
            } else if (check_timeout(ctx, now)) {
                enter_error_state(ctx, HOMING_ERROR_TIMEOUT_MEASURE_RL);
            }
            break;

        case HOMING_STATE_MOVE_TO_CENTER:
            // Wait a bit after stop command before moving to center
            if (!ctx->center_move_started && (now - ctx->state_start_time) >= 100) {
                ctx->state_start_time = now; // Reset timer for center movement
                ctx->center_move_started = true;
                hal_actuator_move_right();
            }

            if (ctx->center_move_started && (now - ctx->state_start_time) >= ctx->center_time_ms) {
                // Reached center position
                hal_actuator_stop();
                change_state(ctx, HOMING_STATE_COMPLETE);
            }

            // Safety check - no switches should be active during center movement
            // Only check after debounce time has passed
            if (ctx->center_move_started &&
                (now - ctx->state_start_time) > (ctx->debounce_ms + 10) &&
                (left_switch || right_switch)) {
                enter_error_state(ctx, HOMING_ERROR_UNEXPECTED_SWITCH);
            }
            break;
    }
}

// Getter functions
homing_state_t homing_get_state(const homing_context_t *ctx) {
    return ctx->state;
}

homing_error_t homing_get_error(const homing_context_t *ctx) {
    return ctx->error_code;
}

bool homing_is_complete(const homing_context_t *ctx) {
    return ctx->state == HOMING_STATE_COMPLETE;
}

bool homing_has_error(const homing_context_t *ctx) {
    return ctx->state == HOMING_STATE_ERROR;
}

// Configuration functions
void homing_set_timeout(homing_context_t *ctx, uint32_t timeout_ms) {
    ctx->timeout_ms = timeout_ms;
}

void homing_set_debounce_time(homing_context_t *ctx, uint32_t debounce_ms) {
    ctx->debounce_ms = debounce_ms;
}

void homing_enable_asymmetric_calculation(homing_context_t *ctx, bool enable) {
    ctx->enable_asymmetric_calculation = enable;
}

// Private function implementations

static bool debounce_switch(switch_debouncer_t *db, bool raw_state, uint32_t now, uint32_t debounce_time) {
    if (raw_state != db->last_raw_state) {
        db->last_raw_state = raw_state;
        db->last_change_time = now;
    } else if ((now - db->last_change_time) >= debounce_time) {
        db->current_state = raw_state;
    }
    return db->current_state;
}

static uint32_t calculate_center_time(const homing_context_t *ctx) {
    if (ctx->time_left_to_right_ms == 0 || ctx->time_right_to_left_ms == 0) {
        return 0; // Invalid measurements
    }

    if (ctx->enable_asymmetric_calculation) {
        // Asymmetric calculation considering different speeds
        // v_right = distance / time_lr, v_left = distance / time_rl
        // For center: time_to_center = distance/2 / v_right
        // Since distance is the same: time_to_center = time_lr / 2
        // But we need to account for speed difference...

        // More accurate asymmetric calculation:
        // Let D = total distance, v1 = right speed, v2 = left speed
        // time_lr = D/v1, time_rl = D/v2
        // To reach center from left: time = (D/2)/v1 = time_lr/2
        return ctx->time_left_to_right_ms / 2;
    } else {
        // Symmetric calculation - simple average
        return ctx->time_left_to_right_ms / 2;
    }
}

static void enter_error_state(homing_context_t *ctx, homing_error_t error) {
    ctx->error_code = error;
    ctx->state = HOMING_STATE_ERROR;
    ctx->measurement_active = false;
    ctx->center_move_started = false;
    hal_actuator_stop();
}

static void change_state(homing_context_t *ctx, homing_state_t new_state) {
    ctx->state = new_state;
    ctx->state_start_time = hal_get_tick_ms();
}

static bool check_timeout(const homing_context_t *ctx, uint32_t now) {
    return (now - ctx->state_start_time) > ctx->timeout_ms;
}
